\section{Perfect Tracking Algorithm} \label{sec:perfect-tracking}

Traditionally, the problem of recording the phylogenies of replicating digital
artifacts has been solved using a ``perfect tracking'' approach where all replication
events are recorded and stored in a tree (or forest, if there are multiple roots) \citep{dolson2023phylotrackpy}.
In this section, we present results on the time and memory size complexity of perfect tracking;
these results will serve as a basis of comparison for our curation policy algorithms in the context
of lineage tracking.

Perfect tracking algorithms are designed to plug into the ongoing replication proces.
As such, they exist in three separate steps: 1) initialization, 2) handling the birth of new objects, and 3) (optionally) handling the removal of existing objects.
The initialization step happens at the beginning of the process being measured.
The birth handling sub-algorithm gets called any time a new object is created.
Similarly, the removal handling sub-algorithm gets called any time an object is removed from the set of currently active objects.

Perfect tracking can be used regardless of whether each artifact has one or multiple parents (i.e. asexual vs. sexual reproduction).
Our analysis here will focus on the case where each artifact has only parent, but most of our results generalize to the multi-parent case.


\subsection{Naive perfect tracking}

The naive perfect tracking algorithm is fairly straightforward and is formally desribed in algorithm \ref{alg:perfect-tracking}.

\input{alg/perfect-tracking.tex}

\subsubsection{Time complexity}

The naive perfect tracking algorithm can be implemented in constant time (see theorm \ref{thm:perfect-tracking-time}).

\input{thm/perfect-tracking-time.tex}

\subsubsection{Size order of growth}

Naive perfect tracking has a very large size order of growth, owing to the fact that it maintains a tree containing a node for every object that ever existed (see theorem \ref{thm:perfect-tracking-space}).

\input{thm/perfect-tracking-space.tex}

\subsection{Perfect tracking with pruning}

For most substantial applications, the amount of memory used by naive perfect tracking is prohibitive.
Instead, most practitioners use an alternative perfect tracking algorithm that includes a ``pruning'' step to reduce memory use (see algorithm \ref{alg:perfect-tracking-pruning}).
This algorithm removes all parts of the phylogeny that are no longer relevant to explaining the history of currently extant objects.
Thus, like naive perfect tracking, it introduces no uncertainty into down-stream analyses.

\input{alg/perfect-tracking-pruning.tex}

\subsubsection{Time Complexity}

The pruning algorithm has a constant (amortized) time complexity (see theorem \ref{thm:perfect-tracking-with-pruning-time}).

\input{thm/perfect-tracking-with-pruning-time.tex}

\subsubsection{Size order of growth}

As with naive perfect tracking, the primary memory cost of this algorithm comes from maintaining the tree of records, $T$.
Thus, our analysis in this section will focus on the size of $T$.
Technically, the worst-case size order of growth of perfect tracking with pruning is the same as for naive perfect tracking (see theorem \ref{thm:perfect-tracking-space}).
However, whereas that order of growth is also the best case for naive perfect tracking, it is a somewhat pathological case with pruning.
When using pruning, such a case would only occur when every object is copied before being removed.
There are some legitimate reasons these cases might occur, but most of them are fairly esoteric (see \ref{sec:perfect-tracking-space-supp}).

% These scenarios might legitimately occur if objects are never removed or the number of objects is allowed to continuously grow, but in these cases $N$ would also be growing continuously.
% They could potentially also happen when tracking digital objects that are copied with very small amounts of stochasticity.

When pruning is used, the asymptotic behavior of the average case is both substantially different from and more practically informative than the asymptotic behavior of the worst case.
Here, we investigate the expected size of $T$ (which we will call $E(|T|)$) in the average case as the population size ($N$) and number of time points ($G$) increase.
Of course, investigating the average case requires making some assumptions about the scenarios where this algorithm may be used.
An expedient assumption to make is that objects to be replicated are selected at random from the population.
While this assumption is obviously not completely true in most cases, it will turn out that $E(|T|)$ is actually smaller for most realistic cases.

Conveniently, the asymptotic behavior of $E(|T|)$ as $N$ increases has been studied under a variety of models of random selection.
The relevant branch of mathematics is coalescence theory, which describes the way particles governed by random processes come together over time [cite Berestycki].
While different models of random selection yield different behavior, nearly models that are realistic for our purposes exhibit ``coalesence'' events in which the most recent common ancestor of the entire current population becomes more recent as a result of old lineages dying out.
This observation implies that when we run our perfect tracking with pruning algorithm for sufficiently long periods of time, on average we should expect our tree to have a long ``stem'' of nodes with a single parent and single child.
The most recent node in this chain will be the most recent common ancestor (MRCA) of the whole extant population.
The descendants of the MRCA will form a more traditional looking tree, which we will call $T_c$.

The expected size of $T_c$ (denoted $E(|T_c|)$; often referred to as $L_n$ in coalescence literature), then, will be the dominant factor affecting $E(|T|)$.
Although the asymptotic behavior of $E(|T_c|)$ depends on the specifics of the evolutionary process, it scales sub-linearly with respect to population size for all realistic models that have been investigated thus far.
How is this possible?
Under realistic models, various subsets of the population will coalesce to common ancestors much faster than the whole population does.
Consequently, there are many shallow branches.
The farther back in $T_c$ you go, the fewer branches there are.
Note that the time to coalescence depends entirely on the population size ($N$); the number of generations ($G$) does not affect the asymptotic growth rate of $E(|T_c|)$.

The precise asymptotic scaling of $E(|T_c|)$ depends on the exact model of random replication used.
Under one common model, Kingman's Coalescent, it is $\mathcal{O}(log(N))$.
Under another reasonable model, the Bolthausen-Sznitman coalescent, it is $\mathcal{O}(\frac{N}{log(N)})$.
%Notably, these are both less than $\mathcal{O}(N)$, which would necessarily be the space complexity of whatever program was generating the phylogeny being tracked.
%Thus, we can conclude that in the average case perfect tracking with pruning will not be the primary factor determining memory usage.
Some questionably-realistic models could also produce the star-shaped coalescent, in which $N$ offspring descend directly from the most recent common ancestor.
While this scenario actually takes less memory in total, its asymptotic growth is $\mathcal{O}(N)$.
Thus, we can claim a loose bound on the average case growth rate of $\mathcal{O}(N + G)$.
Trivially, the ``stem'' part of $T$ can be pruned off when coalescence occurs, producing a bound of $\mathcal{O}(N)$.

Earlier, we mentioned that in practice $T$ will usually be smaller than predicted by these random models.
These random models represent scenarios called ``neutral drift'' in evolutionary theory, which is the case in which coalescence takes the longest.
When some members of the population are more likely to be selected than others (and $N$ is fixed), we expect to see ``selective sweeps'' in which those members of the population outcompete others.
A selective sweep will lead to rapid coalescence.
Thus, in general, in the presence of non-random selection, we expect $T_c$ to be much smaller than we would expect under drift.

Would we ever expect $T_c$ to be larger than under drift?
Only if lineages coexist for longer than we would expect by chance.
Such a regime can theoretically occur when there is selection for stable coexistence or diversity maintenance.
However, such a regime also involves introducing non-random selection.
Thus, in practice, while these regimes maintain multiple deep branches, there is often frequent coalesence within those branches.
Theoretically, though, extreme pressure for diversity could cause $E(|T|)$ to scale faster than $\matchcal{O}(N)$.

% TODO:
% - Address population size
% - Asexual vs. sexual


\subsection{Comparison between perfect tracking and hereditary stratigraphy}

% Considerations:
% - Distributed vs. not
% - Accuracy
% - Memory fluctuations
